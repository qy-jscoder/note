- [一、JS代码编写位置](#一js代码编写位置)
- [三、数据类型](#三数据类型)
  - [1.基本数据类型](#1基本数据类型)
  - [2.对象（引用）类型](#2对象引用类型)
  - [3.判断数据类型](#3判断数据类型)
  - [4.null和undefined的区别](#4null和undefined的区别)
- [四、强制类型转换](#四强制类型转换)
- [五、其他进制的数](#五其他进制的数)
- [六、操作符](#六操作符)
  - [1.一元运算符](#1一元运算符)
  - [2.逻辑运算符](#2逻辑运算符)
  - [3.关系运算符](#3关系运算符)
  - [3.相等运算符](#3相等运算符)
- [七、输入输出语句](#七输入输出语句)
- [八、switch语句](#八switch语句)
- [九、break和continue](#九break和continue)
- [十、对象](#十对象)
  - [1.对象的定义和分类](#1对象的定义和分类)
  - [2.对象的创建](#2对象的创建)
  - [3.对象的删改](#3对象的删改)
  - [4.属性](#4属性)
  - [5.数据类型](#5数据类型)
- [十一、函数](#十一函数)
  - [1.函数的创建](#1函数的创建)
  - [2.函数的使用](#2函数的使用)
  - [3.实参](#3实参)
  - [4.返回值的类型](#4返回值的类型)
  - [5.方法](#5方法)
  - [6.枚举](#6枚举)
  - [7.函数的方法](#7函数的方法)
  - [8.高阶函数](#8高阶函数)
- [十二、作用域](#十二作用域)
- [十三、隐含参数this](#十三隐含参数this)
- [十三、构造函数](#十三构造函数)
- [十四、原型对象](#十四原型对象)
- [十五、垃圾回收机制](#十五垃圾回收机制)
- [十六、数组](#十六数组)
  - [1.创建数组](#1创建数组)
  - [2.数组的常用方法](#2数组的常用方法)
  - [3.数组的常用遍历方法](#3数组的常用遍历方法)
- [十七、arguments](#十七arguments)
- [十八、Date对象](#十八date对象)
- [十九、Math](#十九math)
- [二十、包装类](#二十包装类)
- [二十一、字符串的方法](#二十一字符串的方法)
- [二十二、正则表达式](#二十二正则表达式)
  - [1.创建正则表达式的对象](#1创建正则表达式的对象)
  - [2.支持正则表达式的string方法](#2支持正则表达式的string方法)
  - [3.正则表达式的语法](#3正则表达式的语法)
- [二十三、DOM](#二十三dom)
  - [1.DOM简介](#1dom简介)
  - [2.事件](#2事件)
  - [3.文档的加载](#3文档的加载)
  - [4.DOM查询](#4dom查询)
  - [5.DOM增删改（临时操作，刷新取消）](#5dom增删改临时操作刷新取消)
  - [6.window对象方法](#6window对象方法)
  - [7.实现功能时可能出现的问题](#7实现功能时可能出现的问题)
  - [8.操作内联样式](#8操作内联样式)
  - [9.Element相关属性和方法](#9element相关属性和方法)
- [二十四、BOM](#二十四bom)
  - [1.window：](#1window)
  - [2.Navigator：](#2navigator)
  - [3.Location：](#3location)
  - [4.History：](#4history)
  - [5.Screen：](#5screen)
  - [6.定时器：](#6定时器)
- [二十五、JSON](#二十五json)
  - [1.简介：](#1简介)
  - [2.方法：](#2方法)
## 一、JS代码编写位置

位置不限，但通常都写在body最底下或者HTML根标签的最下面

如果要写在body标签的上面，通常要在js代码外部加上window.onload

## 三、数据类型

### 1.基本数据类型

（1）number

在js中，var a=1+2的形式是可以的，但是进行浮点数运算，可能会有精度上的错误

（2）Boolean

只有两个值，true或者false

（3）string

字符串类型

（4）Null

Null类型的值就是null，但是用typeof检查一个null值时，会返回object 

所以在定义一个变量时，不知道具体数据时，可以先将对象赋值为null，表明该变量就是一个对象

将一个含有数据的对象赋值为null，表明使其成为垃圾对象（被垃圾回收器回收）

（5）undefined

Undefined用typeof检测，返回undefined

### 2.对象（引用）类型

（1）Object

任意对象的类型都是Object

（2）Function（一种特别的对象，可以执行）

加括号表示执行，不加表示对象或者把函数看作一个整体的变量

（3）Array	（一种特别的对象，数值下标）

### 3.判断数据类型

typeof 判断数据类型

instanceof 判断一个对象是否是一个类的实例

=== 全等，即类型相同去情况下判断是否相等，类型不同直接返回false

### 4.null和undefined的区别

null和undefined 两者相等，但是当两者做全等比较时，两者又不等。

null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值。

undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined。

实际上，undefined值是派生自null值的，ECMAScript标准规定对二者进行相等性测试要返回true，

## 四、强制类型转换

（1）数字转换为字符串

例如number转字符串型，假如变量为a,则a.toString();可以使a转换为字符串型，此时a.toString是一个新的值，将其赋给一个新变量来指代，即定义新变量b=a.toString();

此外也可以通过String()方法，也是一样的



值为null或者undefined，无法将其转换为字符串

（2）其他类型转换为数字型

使用Number()函数：

如果是纯数字的字符串，则直接转换为数字

如果字符串有非数字的字符，则转换为NaN。

如果字符串是一个空字符串，或者全是空格的字符串，则转换为数字0

布尔型则转换为0或者1

null和undefined转换为NaN

使用parseInt函数将a转换为number：

parseInt（）可以将一个字符串中有效的整数内容取出来，然后转换为number

parseFloat（）类似，可以将浮点数取出，转换为number

注：对于非String类型使用parseInt或者parseFloat，会先转为String再操作

（3）其他类型转换为BOOlean型

使用Boolean（参数）

数字转Boolean，除了+0、-0和NaN，其余都是true

字符串转Boolean，除了空串，其余都是true

null和undefined转换为Boolean都是false

## 五、其他进制的数

0x开头的数表示十六进制

0开头的数表示八进制

0b表示二进制，但有些浏览器不支持

有时候浏览器搞不清进制，可以用parseInt（a,几进制）表示

## 六、操作符

### 1.一元运算符

（1）对于非number的类型值进行运算，会先转为number型再操作，除了字符串

（2）任何类型的值和NaN或者undefined进行运算，结果都为NaN

字符串中包含非数字的字符，和数字进行除了加法外的运算，结果都为NaN

（3）任何类型的值和字符串进行相加，会先将非字符类型的值转为字符串再和相加的字符串拼接

（4）若想让数字转为字符串，除了用String（）和toString（），还可以和一个空串相加实现一个隐式转换

（5）string类型相加，会进行字符串的拼接

（6）字符串不能换行，要换行需要用“+”将字符串连接起来

（7）字符串和数字相运算，除了加法，其他都是先将字符串转数字，再运算

所以，可以用-0、*1、/1来将字符串转为数字

（8）正负号

对于非number的类型的值先转为number再运算

此外，在运算中，可以<span style="font-weight:bold;color:red;">利用正号</span>来将字符串<span style="font-weight:bold;color:red;">转为数字</span>

例如1++“2”+3=6，其中，先+“2”转为数字，再1+2+3数字加法运算，所以“2”前要用两个加号

### 2.逻辑运算符

（1）&&运算：先将运算值转为Boolean值再运算

第一个值是true，则不管第二个是什么，都返回第二个值

第一个值是false，则不管第二个是什么，都返回第一个值

（2）||运算：与&&运算性质相反

第一个值是true，则不管第二个是什么，都返回第一个值

第一个值是false，则不管第二个是什么，都返回第二个值

### 3.关系运算符

字符串之间，进行大于小于运算，实际是Unicode编码的比较，是两个字符串中的第一位先比大小，相同则继续第二位的比较，以此类推。

只含有数字的字符串和数字比较，实际上是用两个数字比较

所以，遇到两个只含有数字的字符串比较，可将其中一个先转为数字型（利用正号来转换），即可让两个字符串的数字比较

### 3.相等运算符

（1）==表示相等

只含有数字的字符串和数字相等判断，则实际上是字符串的数字和数字相等判断

除了字符串类型的值和数字，都是false

NaN和任意类型值，包括本身，进行相等判断，都是false

可以用isNaN（）函数来判断一个值是否是NaN

（2）===全等

判断是否相等 的同时，还看是否同类型

如果不是同类型，则直接就是false

## 七、输入输出语句

输入语句：

使用prompt（）函数

## 八、switch语句

当前case为true，则从当前语句开始往下依次执行

因此，每个case语句后都要加上一个break；

default相当于if-else中的else语句

注：break只能用于循环或者switch语句中

## 九、break和continue

break跳出离其最近的一层循环，不再执行该循环

continue表示跳出当次循环，继续执行后面的循环

## 十、对象

### 1.对象的定义和分类

对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性

在对象中保存的值是属性，要调用属性可通过对象直接调用

对象的分类：

（1）内建对象

由ES标准中定义的对象，在任何ES的实现中都可以使用

比如，Math、String、Object等

（2）宿主对象

由JS的运行环境提供的对象，目前来讲主要是指由浏览器提供的对象

例如BOM、DOM（即document、console都是浏览器内置的对象）

（3）自定义对象

由开发者自己创建的对象

### 2.对象的创建

（1）var obj=new Object（）；

使用new关键字调用的函数Object（）是构造函数constructor

构造函数专门用来创建对象的函数

（2）var obj={属性名：属性值，属性名：属性值...}（其中可以包含这种形式，属性名：{属性名：属性值}）

在创建对象时，直接指定对象中的属性，属性名可以加引号也可以不加，如果要使用一些特殊属性名，必须加上引号

### 3.对象的删改

删除用delete 属性

修改直接赋值

### 4.属性

如果要使用特殊名字的属性名，不能采用：对象.属性名  的方式，需要使用另一种形式：对象["属性名"]，读取时也使用该形式

使用[]形式更灵活，[]内可以传入一个变量来指代命名的属性名。

对象的属性值可以是任何类型，甚至可以是一个对象、函数，一般都是用函数名来指代函数

当遇到一个陌生的对象，不知道其属性时，可以用in运算符来检查是否有指定的属性，返回值为true或false，语法为：<span style="font-weight:bold;color:red;">“属性名” in 对象</span>

<span style="font-weight:bold;color:red;">属性和变量的区别：</span>

属性没有定义，会返回undefined

变量没有定义，会直接报错

### 5.数据类型

数据类型分为 基本数据类型和引用数据类型

（1）基本数据类型的内存性质

JS中的变量都是保存在栈内存中，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他变量

（2）引用数据类型的内存性质

var obj=new Object();

新建一个变量，存在栈内存中，该变量的值实际是其在堆内存中的地址，指向堆内存中的对象所在的空间，new Object（）表示在堆内存中开辟一块新空间来保存新的对象。

![image-20210130194613797](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210130194613797.png)

var obj2=obj

表示将obj的地址赋给obj2，即obj2也指向obj所指向的堆内存中的空间

所以引用数据类型的一个变量会影响另一个变量



如下图所示，虽然属性名属性值都一样，但是由于所指向的地址不一样，所以引用类型的变量也就不一样，即obj3!=obj4

![image-20210130195459258](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210130195459258.png)


## 十一、函数

### 1.函数的创建

（1）var fun=new Function();

（2）var fun=new Function("可执行的代码")；

（3）function 函数名(){ 代码}

（4）var fun=function(形参，形参...)；

在实际开发中，很少使用构造函函数（即1和2）来创建函数，一般只使用（3）来创建

以（3）的形式创建函数，但没有命名，表示匿名函数

### 2.函数的使用

调用函数时，不会检查函数的实参类型

调用函数时，不会检查函数的实参数量，多余的实参不会被赋值，如果实参的数量少于形参，则没有对应实参的形参时undefined

调用函数名，即不加（），表示函数对象

函数的内部可以声明函数

立即执行函数：（function（）{   }）（参数，参数...）

函数内部是局部变量，函数执行后，变量释放

### 3.实参

实参和形参可以是任意类型，甚至可以是对象、函数

### 4.返回值的类型

return可以跳出函数

返回值可以是任意类型，甚至可以是对象、函数

### 5.方法

函数也可以称为对象的属性，如果一个函数作为一个对象的属性保存，那么称之为这个对象的方法

obj.方法名=function（）{代码 }

### 6.枚举

for(var 变量 in 对象){  console.log("hello");}执行对象的属性个数的次数

for(var 变量 in 对象){  console.log(n);}打印的是对象的所有属性名

for(var 变量 in 对象){  console.log(对象[变量]);}打印的是对象的所有属性值

### 7.函数的方法

使用函数方法时，要通过函数对象来调用（去掉函数的括号就是函数对象）

指定this，参数是谁，this就是谁：

（1）call（）

call（）将实参在对象后依次传递

（2）apply（）

apply（）方法需要将实参封装到一个数组中统一传递

### 8.高阶函数

（1）filter

语法：

~~~js
var arr=xx.filter(function(x){
    return xxx;//筛选
})
~~~

该方法的回调函数必须返回一个布尔值

布尔值为true时，函数内部会将满足要求的n加入到一个新的数组

布尔值为false时，函数内部会过滤掉这次的n

（2）map

map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

map() 方法按照原始数组元素顺序依次处理元素。

语法：

~~~js
var arr=xx.map(function(x){
    return xxx;//数值处理
})
~~~

（3）reduce

语法：

~~~js
arr.reduce(function(prev,cur,index,arr){
...
}, init);
~~~

**arr** 表示原数组；
**prev** 表示上一次调用回调时的返回值，或者初始值 init;
**cur** 表示当前正在处理的数组元素；
**index** 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
**init** 表示初始值。（一般为0）

实例

~~~js
var arr = [3,9,4,3,6,0,9];
var sum = arr.reduce(function (prev, cur) {
    return prev + cur;
},0);
~~~

以上三个函数可以链式调用

## 十二、作用域

作用域指一个变量的作用的范围

变量的声明提前：

使用var关键字声明的变量，会自动在所有的代码执行之前被声明

在JS中有两种作用域：

（1）全局作用域

直接编写在script标签内的JS代码，都在全局作用域

全局作用域在页面打开时创建，在页面关闭时销毁

在全局作用域中有一种全局对象window，它代表一种浏览器的窗口，由浏览器创建。所以我们自定义的变量、函数实际上是写在window对象中，作为window对象的属性、方法

（2）函数作用域

使用函数声明形式（function 函数名（）{}）创建的函数，会在所有代码执行之前就被创建，所以函数声明形式的函数可以在任意位置创建

其他几种方式创建的函数不具有以上性质

<hr/>

函数作用域中的变量没有用var定义，直接赋值，则会变为全局变量

调用函数时创建函数作用域，函数执行结束，函数作用域销毁

每调用一次函数就会创建一个新的函数作用域，他们之间是相互独立的

在函数作用域中可以调用全局作用域的变量，反之不能

在函数作用域中调用变量由自己开始一层一层向外找

定义形参就相当于在函数作用域中声明了变量

## 十三、隐含参数this

（1）调用的是函数，this就永远都是window（window就是全局作用域）

（2）以方法的形式调用，this就是被调用方法的那个对象

（3）通过构造函数创建对象，函数中的this就指的是创建的对象

（4）原型方法中的this（谁调用this所在的函数，那么this就指向谁）

例：

~~~js
Array.prototype.pt = function() {
    console.log(this)
}
var a = [1,2,3,4]
console.log(a.pt())    // (4) [1, 2, 3, 4]
~~~

（5）给元素绑定事件，this指的是元素

## 十三、构造函数

创建一个构造函数，专门用来创建Person对象

构造函数和普通函数的区别就是调用方式的不同，且构造函数的首字母一般都是大写

普通函数是直接调用，构造函数需要使用new关键字来调用

<hr/>

创建构造函数：var per=new Person();（此处称per为Person类的一个实例）

在构造函数中用this给新建的对象属性赋值，this指的是每一个新建的对象

使用同一个构造函数创建的对象，称为一类对象，也将该构造函数称为一个类

可以使用instanceof检查一个对象是否一个类的实例，语法：对象  instanceof 构造函数，返回值为true或false

<span style="font-weight:bold;color:red">注：所有的对象都是Object的后代，所以任何对象instanceof Object（）都是true</span>

![image-20210131204144569](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210131204144569.png)

构造函数的执行流程：

1.立即创建一个新的对象

2.将新建的对象设置为函数中this，在构造函数中使用this来引用新建的对象

3.逐行执行函数中的代码

4.将新建的对象作为返回值返回

<hr/>

每次通过构造函数实例化一个对象，都会新建一个方法，过于繁琐且占用过多空间

优化方法：将Person类中的fun方法放在全局作用域中定义，将上述    this.sayName=function(){console.log(this.name);}   改成  this.sayName=fun

## 十四、原型对象

创建的每一个函数，解析器都会向函数中添加一个属性prototype，这个属性的属性值就是一个地址，地址指向一个原型对象。

如果函数作为普通函数调用prototype没有任何作用

当以构造函数的形式调用时，它创建的对象会有一个隐含的属性指向该构造函数的原型对象，我们可以通过_ __proto_ __（左右两边各有2个下划线）来访问

简单来说，访问原型对象，构造函数用prototype，对象用_ _proto_ _

![image-20210131223721922](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210131223721922.png)

![image-20210131223630885](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210131223630885.png)

原型对象相当于一个公共区域，所有同一个类的实例都可以访问到这个原型对象，可以将对象中公有的内容，统一设置到原型对象中

<hr/>

当访问对象的一个属性或者方法时，它会先在对象中查找，有则直接调用，没有则到原型对象中找

使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true

console.log("属性" in 对象)

使用对象的hasOwnProperty（）方法检查对象自身中是否含有该属性

语法：console.log(对象.hasOwnProperty("属性"));

<hr/>

原型对象也是对象，所以它也有原型，但是有尽头，最多可以到一个对象的原型的原型里找（即自身的原型找到头了，就从父类Object对象中找，最多最多到Object的的原型，如果依然没有，则返回undefined）

<hr/>

当我们在页面上打印对象时，实际上是输出对象的toString（）方法的返回值

toString（）方法放在对象的原型的原型里

如果不希望输出[object  object]，可以为对象添加一个toString（）方法

<hr/>

在原型中添加属性和函数，要在 构造函数.prototype中添加，但是该类的实例调用原型中的属性或者函数，可以直接调用

## 十五、垃圾回收机制

当一个对象没有任何的属性或变量对他进行引用，此时我们将永远无法操作该对象，这个对象就是一个垃圾，浏览器会自动清理，将其从内存中销毁，开发者无法进行垃圾回收的任何操作。

只需将对象设为null即可

## 十六、数组

数组也是一个对象，与普通对象不同的是，数组使用数字作为索引操作元素，普通对象使用字符串来作为属性名

如果读取到不存在的索引，不会报错而是返回undefined

对于有者连续的索引的数组，使用length可以获得实际数组长度

对于非连续的数组，使用length只能得到数组长度为最大索引数+1

给数组长度赋值，如果大于实际长度，多出来的部分会空着；如果如果小于实际长度，多出来的部分会删去

如果想给数组添加元素，可以用arr[arr.length]=值

数组的元素可以是任意类型

### 1.创建数组

（1）var arr=new Array（）；

使用构造函数创建，可以同时添加元素，将元素作为参数传递

（2）var arr=[ ];

使用字面量创建，可以在创建时直接添加元素

### 2.数组的常用方法

push（）给数组末尾添加一个或多个元素

pop（）给数组从末尾开始删除并返回最后一个元素

unshift（）给数组开头添加一个或多个元素，并返回新的数组长度

shift（）删除并返回数组的第一个元素

slice（start，end）从指定索引范围内提取元素，包含开头但不包含结尾索引的元素，第二个参数不写表示从指定位置到最后，参数为负数表示从尾到头第几个元素。该方法不会影响到原数组，而是放到一个新数组内

splice（start，amount，新增元素）删除数组的指定范围的元素，会改变原数组，并将删除元素作为返回值返回，两个参数，第一个表示开始删除的位置，第二个参数表示删除元素的个数，第三个可加可不加，表示要添加的元素，元素会放到start索引前面

contact（）可以连接两个或多个函数，并将新数组返回，要连接多少数组，就将多少数组作为参数。不会对原数组产生影响

join（）将数组转换为一个字符串，将字符串作为结果返回，参数为一个表示字符串中的分隔符

reserve（）翻转数组，会影响原数组

sort（）对原数组中的元素排序，默认按照Unicode编码进行排序。可以指定排序规则，添加回调函数，回调函数需要定义2个形参（数组元素两两比较）。浏览器会根据回调函数 的返回值来决定元素的顺序。

如果返回一个大于0的数，元素惠交换位置

如果返回一个小于0的值，元素位置不变

如果返回0，则认为两个元素相等，不交换位置

### 3.数组的常用遍历方法

（1）for循环

（2）forEach（）方法，需要一个函数作为参数（由开发者创建但不是由开发者调用的函数称为 回调函数）

语法：数组.forEach（function（a）{ }）；浏览器会在回调函数中传递三个参数

第一个参数是当前遍历的元素，第二个参数是对应元素的索引，第三个参数就是正在遍历的数组

~~~js
var arr = [1,2,3,4];
var sum =0;
arr.forEach(function(value,index,array){
    array[index] == value; //结果为true
    sum+=value; 
 });
console.log(sum); //结果为 10
~~~



## 十七、arguments

在调用函数时，浏览器每次都会传递两个隐含的参数：

（1）函数上下文对象this

（2）封装实参的对象arguments。

arguments是一个类数组对象，但不是数组对象，可以通过索引来操作数，也可以获取长度

调用函数时，无论是否定义形参，传递的实参都会在arguments中保存，可以通过arguments.length获取长度

有一个属性callee，该属性对应一个函数对象，就是当前正在执行函数的对象

## 十八、Date对象

Date对象表示一个时间

创建一个对象，不作特殊处理，则表示当前执行时的时间

创建一个指定的时间，则在创建时传递一个表示时间的字符串作为参数，形式：“12/12/2020 12:12:12”

Date对象的方法：

（1）getDate（）表示获取当前对象是周几，就返回几，返回值0~6,0表示周日，1表示周一

（2）getFullYear（）表示获取当前时间对象的年份，返回值为年份

（3）getMonth（）表示获取当前时间对象的月份，返回值范围0~11,0表示1月，1表示2月

（4）getTime（）表示获取当前时间对象的时间戳，时间戳表示从格林威治标准时间的1970年1月1日，0时0分0秒到当前时间所花费的毫秒数（1秒=1000毫秒 ）

可以通过Date.now（）来获取当前时间的时间戳

还可以利用时间戳来计算程序运行时间，程序块前计算一次，程序块后计算一次，相减可得程序运行时间

## 十九、Math

Math是一个工具类，不是一个构造函数，直接拿来就用

Math.PI表示圆周率

Math.abs（）表示对一个数取绝对值

Math.ceil（）表示对一个数向上取整

Math.floor（）表示对一个数向下取整，浮点数的小数部分就会被舍掉

Math.round（）表示对一个数四舍五入取整

Math.random（）表示在0~1之间取一个随机数（不包含0和1）

Math.max()表示取多个数的最大的一个，参数即为要比的值

Math.min()表示取多个数的最小的一个，参数即为要比的值

## 二十、包装类

将基本数据类型转为引用数据类型，即对象

所有对象转为布尔值都为true

注：当我们对一些基本数据类型的值取调用属性和方法时，浏览器会临时使用包装类将其转为对象，然后在调用对象的属性和方法，调用结束再恢复为基本数据类型

例：

![image-20210201232253366](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210201232253366.png)

第一次先临时将字符串类型的s转为对象，设此时的对象为obj-s1,再给该对象添加属性，加完就销毁对象

第二次打印s的属性，但是s不是对象，所以临时转为对象，设此时的对象为obj-s2,再打印其属性，打印完就销毁

显然，无法打印,因为obj-s1已经被销毁了，添加的属性也随之销毁，所以打印时，找不到hello属性，所以结果为undefined

## 二十一、字符串的方法

在底层字符串是以字符数组的形式保存的

（1）charAt（）

可以返回字符串中指定的字符，以索引获取指定字符。不会改变原数组

（2）charCodeAt（）

获取指定位置字符的Unicode编码。不会改变原数组

（3）formCharCode（）

通过String.formCharCode（）的形式调用，根据字符编码获得字符，参数就是字符编码。不会改变原数组

（4）contact（）

连接两个或多个字符串。不会改变原数组

（5）indexOf（）

检查字符串中是否含有指定内容，如果有则返回该内容第一次出现的索引，如果没有则返回-1。只有一个参数表示指定字符，有两参数则第二个表示从字符串中指定位置开始查找。不会改变原数组

（6）lastIndexOf（）

与（5）类似，但不同的是，该方法从后往前找

（7）slice（start，end）

从指定索引范围内提取元素，包含开头但不包含结尾索引的元素，第二个参数不写表示从指定位置到最后，参数为负数表示从尾到头第几个元素。该方法不会影响到原数组，而是放到一个新数组内

（8）substring（）

与slice（）几乎一致，但不同的是，参数不接受负值，负值都默认为0，还会自动调整参数位置，如果第一个参数大于第二个参数，那么会交换位置。

（9）substr（）

与slice（）类似，但第一个参数表示开始的位置，第二个参数表示截取的长度

（10）split（）

将字符或字符串作为参数来起到分隔符的作用，将一个字符串拆分为数组

如果将空串作为参数，则会将每一个字符拆分开放入数组中（包含空格）

（11）toUpperCase（）

将一个字符串全转为大写并返回

（12）toLowerCase（）

将一个字符串全转为小写并返回

## 二十二、正则表达式

用于定义一些字符串的规则

计算机可以根据正则表达式来检查一个字符串是否符合规则，将字符串中符合规则的内容提取出来

### 1.创建正则表达式的对象

<span style="font-weight:bold;">语法1</span>:var 变量=new RegExp（“正则表达式”，“匹配模式”）;（常用该方式创建）

如果参数只有一个，且为一个字符串。则这个正则表达式可以检查一个字符串中是否含有该参数

<hr/>

可以用test（）方法来检查一个字符串是否符合正则表达式的规则，返回值为true或false（简单来说就是检查一个字符串中是否含有该正则表达式）

该方法且严格区分大小写。

匹配模式可以有两种：

（1）为“i”  ，表示忽略大小写

（2）为“g”  ，表示全局匹配模式，即找到第一个符合处后继续查找



<span style="font-weight:bold;">语法2</span>: var 变量= /正则表达式/匹配模式（该方式一般不用）

例：

![image-20210202182817021](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210202182817021.png)

![image-20210202183251106](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210202183251106.png)

 

中括号[] 和竖线|都可以表示 或  的关系（[ab]==a|b）

[a-z]表示a到z中的任意字符都可以

[A-Z]表示A到Z中的任意字符都可以

[^字符]表示除了指定字符都可以

### 2.支持正则表达式的string方法

（1）search（）

搜索到字符串中的指定内容。如果搜索到则返回第一次出现的索引，如果没有则返回-1

可以接受一个正则表达式作为参数，再根据正则表达式来检索字符串

（2）match（）

根据正则表达式，从一个字符串中提取出符合条件的内容，并将其封装在一个数组中国返回

默认只会找第一个符合要求的内容，可以通过设置全局匹配模式来匹配所有（修饰符为g），可以设置多个匹配模式，且顺序无要求

（3）replace（）

可以将字符串中指定内容替换为新的内容，并返回新的字符串。参数有两个，1.被替换的内容。2.新内容。默认只会替换第一处匹配的内容。

注：正则表达式可以作为参数，正则表达式表达是什么含义就表示什么

（4）split（）

与其他对象的方法使用规则几乎一致。默认为全局匹配

### 3.正则表达式的语法

（1）量词{n}

通过量词设置一个内容出现的次数，即不仅仅是一个字符，还有可能是一个括号内的内容

量词只对它前面的一个内容起效

{ n}为出现n次

{m,n}出现m到n次，m必定小于n

{n,}出现n次以上，只要是满足n以上次就都可以

（2）+表示前面的一个内容至少一个，相当于{1,}

（3）*表示0个或多个，相当于{0,}

（4）？表示0或1个，相当于{0,1}

（5）^紧跟着一个内容

表示检查一个字符串是否是以 紧跟着的内容为开头

（6）一个内容后紧跟着 ￥

表示检查一个字符串是否是以    该内容    为结尾

如果/^内容￥/表示该内容既是开头也是结尾

如果/^内容|内容￥/表示该内容是开头或者是结尾

（7）.

一个点表示任意字符都可以

![image-20210202204126807](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210202204126807.png)

（8）正则表达式中各种转义字符

\w表示任意字母、数字、_

\W表示除了字母、数字、_

\d表示任意数字

\D表示除了数字

\s表示空格

\S表示除了空格

\b表示单词边界，即children不是child，但如果没有单词边界，就true了，与事实不符，所以需要用到单词边界，语法:正则表达式/\bchild\b/表示要求含有child单词

\B表示除了单词边界



注：A-z表示任意大小写字母，但包含下划线

## 二十三、DOM

### 1.DOM简介

DOM为document object model文档对象模型

JS通过DOM来对HTML文档进行操作

文档指的是整个HTML网页文档

对象指的是将网页的每一个部分都转换为了一个对象

模型用来表示对象之间的关系，方便我们获取对象

（1）节点

网页中的 每一个部分都是一个节点，不同节点有不同类型

常用节点分为四类：文档节点、元素节点、属性节点、文本节点

![image-20210203174040496](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210203174040496.png)



文档节点：document

### 2.事件

事件就是用户和浏览器之间的交互行为，比如：点击按钮、鼠标移动、关闭窗口等

可以为事件绑定处理函数的形式来响应事件，当事件被触发，对应函数被调用，都写在js中，便于维护

在事件的响应函数中，响应函数是给谁绑定的，this就是谁

鼠标事件：

（1）onclick 鼠标单击触发事件

（2）ondblclick 鼠标双击触发事件

（3）onmousemove 鼠标移动到指定位置触发事件

（4）onscroll事件将在滚动条滚动时触发

（5）onmousemove事件将会在鼠标在元素中移动时被触发

（6）onmousedown事件在鼠标按下时触发

（7）onmouseup事件在鼠标左键松开时触发

（8）onmousewheel事件在鼠标滚轮滚动时触发

但是该属性在火狐中不受支持

火狐中通过DOMMouseScroll来绑定滚动事件（注：该事件需要通过addEventListener（）函数来绑定）

可以通过event.wheelDelta来获取鼠标滚轮滚动的方向

负值为向下滚动，正值表示向上滚动

然而，该属性也不受火狐支持。在火狐中，可以通过event.detail来获取，拥有wheelDelta类似的功能，但是

负值为向上滚动，正值表示向下滚动



注：使用addEventListener（）方法绑定响应函数时，取消默认行为不可以通过return false来取消默认行为。可以通过event.preventDefault（）方法来实现，但是IE8不支持



键盘事件：

键盘事件一般会绑定一些可以获取到焦点的对象或是document

此处的event表示键盘按键

（1）onkeydown 按键被按下

对于该事件，按住按键不松开时，事件会一直触发

触发的事件第一次和第二次间隔会长一些，但之后会越来越快

（2）onkeyup按键被松开

（3）keyCode属性  通过Unicode编码来获取键盘键值

—altKey			—ctrlKey—			shiftKey

这三个属性用来判断alt、Ctrl、shift是否被按下，如果按下则返回true，否则返回false





<hr/>

<span style="color:red;font-weight:bold;">事件对象：</span>

当事件的响应函数被触发时，浏览器每次都会将一个事件对象event作为实参传递进响应函数（可以将event看作鼠标，当需要进行鼠标的相关的操作时，例如鼠标自动移位，div移动等问题，就用event）

在事件对象中封装了当前事件相关的一切信息，比如鼠标的坐标、鼠标滚轮滚动方向、键盘哪个按键被按等

（1）clientX和clientY

获取当前横纵坐标上的位置

相当于整个页面

（2）pageX和pageY

获取鼠标相对于当前页面的坐标，但是这两个属性在IE8中不支持

（3）获取滚动条滚动的距离

Chrome浏览器认为滚动条是body的，可以通过document.body.scrollTop获得

火狐等浏览器认为滚动条是HTML的

<span style="color:red;font-weight:bold;">事件的冒泡（Bubble）：</span>

所谓的冒泡指的是事件的向上传导，当后代元素的事件被触发时，其祖先元素的相同事件也会被触发

在开发中，大部分冒泡都是有用的，如果不希望有事件冒泡发生可以通过事件对象来取消冒泡（event.cancelBubble=true）

<span style="color:red;font-weight:bold;">事件的委派：</span>

只绑定一次事件，即可应用到多个元素上，即使元素是后加的

将事件绑定到元素的共同的一个祖先元素上，这样当后代元素上的事件触发时，会一直冒泡到祖先元素，从而通过祖先元素的响应函数来处理事件。

事件委派是利用了冒泡，通过委派可以减少事件绑定的次数，提高程序的性能

然而在委派时，可能出现不希望的情况，即点击祖先元素下的空白部分也可以触发事件，这时可以通过event.target.属性来选中要触发事件的元素

<span style="color:red;font-weight:bold;">事件的绑定：</span>

使用  对象.事件=函数  的绑定形式

只能同时为一个元素的一个事件绑定一个响应函数

不能绑定多个，如果绑定多个，后面的会覆盖前面的

<hr/>

addEventListener（）：

也可以为元素绑定响应函数，该方法中的this是绑定事件的对象

参数：（1）事件的字符串，不要on

（2）回调函数，当事件触发时该函数会被调用

（3）是否在捕获阶段触发事件，需要一个布尔值，一般都传false

该方法可以给一个元素的相同事件绑定多个响应函数，当事件被触发时，响应函数会按照函数的绑定顺序执行



attachEvent（）：

在IE8中可以使用该方法来绑定事件，该方法中的this是window

参数：（1）事件的字符串，不要on

（2）回调函数

该方法也可以给一个元素的相同事件绑定多个响应函数，当事件被触发时，后写的响应函数先执行，先写的后执行

<hr/>

自定义一个bind函数，用来为指定元素绑定响应函数（不同事件分别绑定不同的响应函数，不需要用该方法）

参数：（1）obj 要绑定事件的对象

（2）eventStr  事件的字符串（不要on）

（3）callback  回调函数

~~~js
function bind(obj,eventStr,callback){
    //此处不加（），因为对象没有则返回undefined，undefined转布尔值为false
    //而变量没有，则直接报错
    if(obj.addEventListener){
        obj.addEventListener(eventStr,callback,false);
    }
    else{
        //此处用一个匿名函数作为参数，在匿名函数中调用回调函数，也就是自己来调用
        obj.attachEvent("on"+eventStr,function(){
            callbak.call(obj);
        });
    }
}
bind(btn,"click",function(){
    alert(this);
});
~~~

<span style="color:red;font-weight:bold;">事件的传播：</span>

和事件的冒泡方向相反，是由外向内的

W3C综合了两种方式，将事件传播分为了3个阶段：

（1）捕获阶段

在捕获阶段时，从最外层的祖先元素向目标元素进行事件的捕获，但是默认不会触发事件

（2）目标阶段

事件捕获到目标元素，补捕获结束开始从目标元素上触发事件

（3）冒泡阶段

事件从目标元素向它的祖先元素传递，依次触发祖先元素上的事件



注：如果希望在捕获阶段就触发事件，可以将addEventListener（）的第三个参数设置为true

一般情况下，我们不会希望在捕获阶段就触发事件，所以参数一般就是false

（IE8以下浏览器没有捕获阶段）



<span style="color:red;font-weight:bold;">鼠标左键拖拽元素，松开后出现的鼠标自动移位问题</span>

（1）通过鼠标的当前位置，先求div的偏移量：

div的x轴偏移量ol：鼠标.clientX-元素.offsetLeft

div的y轴偏移量ot：鼠标.clientY-元素.offsetTop

（2）再将移动后鼠标的

鼠标的X轴位置：event.clinetX-ol

鼠标的Y轴位置：event.clinetY-ot

### 3.文档的加载

浏览器在加载一个页面，即文档时，都是从上到下的顺序加载的。读取到一行就运行一行

所以，一般scrip都是放在body的最后

但如果不想，可以将事件对应的响应函数写在window.onload函数里，表示在页面加载完再执行该函数

从性能上来说，将scrip写在body最后更好，从管理上来说，将scrip写在head里更好

### 4.DOM查询

获取元素节点：

通过<span style="color:red;font-weight:bold;">document对象</span>来调用

（1）getElementById（）通过id属性获取一个元素节点对象

（2）getElementsByTagName（）通过标签名获取一组元素节点对象，会返回一个类数组对象，所有查询的元素会放在对象中

（3）getElementsByName（）通过name（即表单name）属性来获取一组元素节点对象

（4）document.body属性获取body标签

（5）documentElement属性获取HTML根标签

（6）all属性可以获取页面中所有的元素

（7）getElementsByClassName方法  	

根据元素的class属性查询一组元素节点对象

根据class属性获取一组元素节点对象，但是该方法<span style="color:red;font-weight:bold;">不支持IE8及以下的浏览器</span>

如果对象是元素，则获得的是子元素中符合条件的元素

（8）querySelector（）

需要一个选择器的字符串作为参数，可以根据一个css选择器来查询一个元素节点对象

虽然IE8中没有getElementsByClassName（），但是可以使用该方法

使用该方法总会返回唯一的一个元素，如果满足条件的元素有多个，那么它只会返回<span style="color:red;font-weight:bold;">第一个</span>

获取的是NodeList。

NodeList和HTMLCollection 并不是文档状态中的一个静态快照，但是这个方法返回的NodeList，是静态的，不随文档的更新而变化。

（9）querySelectorAll（）

即使符合条件的元素只有一个，也返回nodelist数组

和（8）类似，但它返回的是所有符合条件的元素



<hr/>

获取元素节点的子节点：

通过<span style="color:red;font-weight:bold;">具体的元素节点调用</span>

（1）getElementsByTagName（）

-方法

返回当前节点的指定标签名的后代节点

（2）childNodes

-属性

表示当前节点的所有子节点(包含标签间的空白和标签)

（3）firstChild

-属性

表示当前节点的第一个子节点（包含空白）

（4）lastChild

-属性

表示当前节点的最后一个子节点

（5）parentNode

-属性

表示当前节点的父节点

（6）previousSibling

-属性

表示当前节点的前一个兄弟节点

（7）previousElementSibling

-属性

表示当前节点的前一个兄弟元素，不支持IE8以下

（8）nextSibling

-属性

表示当前节点的后一个兄弟节点

（9）children

-属性

获取所有的子元素

<hr/>

获取文本节点：

innerHTML属性，用于获取元素内部的文本

innerText属性，用于获取元素内部的文本，自动将HTML标签去除

获取元素节点属性：

直接通过  对象.属性名  来获取

例如：元素.id、元素.value。	但class不能采用如此方式，读取class只能用元素.className

### 5.DOM增删改（临时操作，刷新取消）

（1）createElement（）方法

用于创建一个元素节点对象

它需要一个标签名作为参数，将根据标签名创建对应的标签，并将创建好的对象作为返回值返回。

要添加子节点可以通过另一种方法：

使用innerHTML属性来添加

语法：父节点.innerHTML+="HTML代码"

该方法影响太大，一般不推荐使用，一般建议两者结合使用，如下所示：

获取父节点，创建一个子节点，修改其innerHTML（即文本），再将该子节点添加到其父节点中

（2）createTextNode（）方法

用于创建一个文本节点对象

需要一个文本内容作为参数，将会根据内容创建文本节点，并将新的节点返回。

（3）appendChild（）方法

向一个父节点中添加一个新的子节点

语法：父节点.appendChild（子节点）

（4）insertBefore（）

在指定的子节点前插入新的子节点

语法：父节点.insertBefore（新节点，旧节点）

（5）replaceChild（）

可以用指定的子节点替换已有的子节点

语法：父节点.replaceChild（新节点，旧节点）

（6）removeChild（）

删除子节点

语法：父节点.removeChild（子节点）

 

注：如果不知道父节点，可以通过一个已知子节点的parentNode属性来获取父节点

注：超链接点击会默认跳转，如果不想跳转，就return false或者在a标签上将href属性改为javascript：；

表单提交同理，要取消默认行为，操作同上

### 6.window对象方法

（1）confirm（“ ”）

弹出一个带有参数内容的确认和取消按钮的提示框

点击确认会返回true，取消会返回false

### 7.实现功能时可能出现的问题

for循环会在页面加载完立即执行

而响应函数会在触发时执行，显然当响应函数执行时，for循环已执行结束，所以，不能只能用this

### 8.操作内联样式

在js中修改css样式

<span style="font-weight:bold;color:red">语法：元素.style.样式=“样式值”</span>

注意点：

（1）只能获取有css样式的元素

（2）如果css的样式中含有“-”号，这种样式名是不合法的，应当去掉“-”号，并将其改为驼峰命名法，即将“-”号的首字母改为大写

（3）通过style属性设置的样式都是内联样式，而内联样式都有有较高的优先级，所以通过js修改的样式往往会立即显示

（4）如果在内联样式中有！important，会导致js不能覆盖样式，此时会导致js修改失败，所以css中尽量不要添加！important

（5）通过style属性修改元素样式，每修改一个样式，浏览器会重新渲染一次，这样的执行的性能比较差，而且这种形式在我们要修改多个样式时，也不太方便

此时，我们可以通过<span style="font-weight:bold;color:red">修改元素的css属性</span>来间接的修改样式，这样一来我们只需要修改一次，即可同时修改多个样式。浏览器只需重新渲染页面一次，性能比较好，这种方式，可以使表现和行为进一步分离。语法：元素.className=“类名”

如果只添加一些原本没有的样式，则语法：元素.className+=" 类名"（注：此时要给类之间加个空格，来表示两个类）

<span style="font-weight:bold;color:red">注：</span>

<span style="font-weight:bold;color:red">（1）查询自带属性，直接带用属性方法查询：元素.属性</span>

<span style="font-weight:bold;color:red">（2）查询自定义属性要用style方法：元素.style.属性</span>



<hr/>

获取元素的当前显示的样式（以下两种都是只读的，只能读不能修改）

<span style="font-weight:bold;color:red">语法：元素.currentStyle.样式名 或者  元素.currentStyle[样式名]</span>

注意点：

（1）只有IE浏览器支持



<span style="font-weight:bold;color:red">语法：getComputedStyle（）.样式名  或者getComputedStyle（）[样式名]</span>

注意点：

（1）这个方法来获取当前的样式，该方法是window对象的方法，window可省

（2）第一个参数是要获取样式的元素，第二参数可以传递一个伪元素，一般是null

（3）该方法会返回一个对象，对象中封装了当前元素的样式

（4）大部分浏览器都支持该方法，并且IE8以上支持

（5）如果获取的样式没有设置，则会取到真实的值，而不是默认值，当前窗口显示多少，就获取到多少

### 9.Element相关属性和方法

（1）clientWidth和clientHeight

这两个属性可以获取元素的可见宽高，包括内容区和内边距

返回值不带px单位，可以直接用于计算

只能用于读取，无法修改

（2）offsetHeight和offsetWidth

获取整个可见区域的宽高，包括内容区、内边距和边框

（3）offsetParent

可以用来获取当前元素的定位父元素

会获取到离当前元素最近的开启了定位的祖先元素

（4）offsetLeft和offsetTop

offsetLeft：当前元素相对于定位父元素的水平偏移量

offsetTop：当前元素相对于定位父元素的垂直偏移量

（5）scrollWidth和scrollHeight

可以获取元素整个滚动区域的宽高

（6）scrollLeft和scrollTop

scrollLeft：当前滚动条水平方向上的距离

scrollTop：当前滚动条水平方向上的距离

注：可以用scrollHeight-scrollTop==clientHeight判断是否滚动条到底

宽度同理

注：偏移量只对开启了定位的元素起作用

## 二十四、BOM

BOM是浏览器对象模型

BOM使我们可以通过js来操作浏览器

BOM为我们提供了一组对象来完成对浏览器的操作

<span style="font-weight:bold;color:red">BOM对象如下：</span>

### 1.window：
代表的是整个浏览器的窗口，同时也是网页的全局对象

### 2.Navigator：
代表的是当前浏览器的信息，通过该对象可以识别不同的浏览器

（1）由于历史原因，该对象中的大部分属性已经不能帮助我们识别浏览器。一般我们只会使用userAgent来判断浏览器的信息。

useragent是一个字符串，这个字符串包含有用来描述浏览器信息的内容

不同的浏览器有不同 的userAgent

（2）但是Edge浏览器的userAgent中没有相关标识，将其看做Chrome浏览器

### 3.Location：
代表当前浏览器的地址栏信息，通过Location可以获取，或者操作浏览器跳转页面

（1）可以直接给location赋值指定网址，会跳转对应网页，并生成相应的历史记录

（2）直接打印location，可以获取到当前网页的地址栏信息

（3）assign（）方法

用来跳转到其他页面，作用和直接修改location一样

（4）reload（）方法

用于重新加载当前页面，作用和刷新一样

如果在方法中传入true作为参数，则会强制清空缓存刷新页面

（5）replace（）方法

使用一个新的页面替换当前页面，调用完毕也会跳转页面

不会生成历史记录，且无法回退页面

### 4.History：
代表浏览器的历史记录，可以通过对该对象来操作浏览器的历史记录

由于隐私，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页

而且操作只在当次访问时有效

（1）length属性

可以获取到当次访问的链接数量

（2）back方法

回退到上一个页面

（3）forward方法

前进到下一个页面

（4）go方法

跳转到指定页面，需要一个整数作为参数

1：表示跳转一个页面，相当于forward（）

2：表示跳转两个页面

-1：表示向后跳转一个页面，相当于back（）

-2：表示向后跳转多个页面

### 5.Screen：
代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息

### 6.定时器：

（1）setInterval（）方法

定时调用：可以将一个函数，每隔一段时间执行一次

参数：1.回调函数，该函数会每隔一段时间被调用一次

​			2.每次调用间隔的时间，单位是毫秒

返回值：返回一个Number类型的数据

然而每点击一次按钮，就会开启一个定时器，点击多次就会开启多个定时器，会导致定时器的速度变快，并且我们只能关闭最后一个开启的定时器

（2）clearInterval（）

关闭指定的定时器，需要一个定时器的标识作为参数，这样将关闭对应的定时器

可以接收任意参数，如果参数是一个有效的定时器标识，就暂停对应定时器

如果参数是一个无效的定时器标识，那么不做处理

（3）setTimeout（）

延时调用一个回调函数不马上执行，而是隔一段时间以后再执行，且只执行一次

参数有两个：	

​		参数1：回调函数，指定时间后执行一次

​		参数2：延时时长

## 二十五、JSON

### 1.简介：

js的对象只有js自己认识，其他的语言不认识

JSON就是一个特殊格式的字符串，这个字符串可以被任意的语言所识别，并且可以转换为任意语言的对象，JSON在开发中主要用来数据的交互

JSON：JavaScript Object Notation JS 对象表示法

JSON和js对象的格式一样，只不过json字符串中的 属性名必须加双引号，其他和JS语法一致



![image-20210208001237138](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210208001237138.png)



### 2.方法：

（1）JSON.parse（）（JSON转为js对象的方法）

需要一个JSON字符串作为参数，会将字符串转为JS对象

（2）JSON.stringify（）（js对象转为JSON的方法）

需要一个js对象作为参数，会返回一个JSON字符串

（3）eval（）

可以执行字符串形式的JS代码，并将结果返回

如果使用eval（）执行的字符串中含有{}（大括号），它会将{}当成是代码块

如果不希望将其当成代码块解析，则需要在字符串前后加上“（”和“）”

例如：![image-20210208003705893](D:\web self-learn\HTML+CSS\JS笔记.assets\image-20210208003705893.png)

但是在开发中尽量不要使用，首先它的执行性能比较差，然后还有安全隐患

注：JSON这个对象在IE7及以下的浏览器不支持。如果一定要兼容IE7及以下浏览器的JSON操作，则可以通过引入一个外部的JS文件来处理。





易忘点

（1）直接获取的方式只能获取节点本来具有的属性，而getAttribute（）可以获取自己定义的属性



